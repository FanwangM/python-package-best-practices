---
title: "Continuous Integration"
teaching: ??
exercises: ??
questions:
- "How can we automate testing?"
- "How do we link a repository on Github to continuous integration services?"
objectives:
- "Explain the concept and benefits of continuous integration."
- "Demonstrate how to setup continuous integration using TravisCI and Codecov."
- "Familiarize learners with Travis YAML configuration file and basic options."
- "Show how TravisCI integrates with Github."
keypoints:
- "Continuous integration services are useful to automate development steps, such as testing."
---

> ## Prerequisites
>
> - All Python code and tests described so far in the lesson.
> - Configured Git and GitHub account (described in set-up)
> - Pushed up-to-date version - with tests - of the `molecool` project to Github.
{: .prereq}

From [Wikipedia](https://en.wikipedia.org/wiki/Continuous_integration), continuous integration (CI) is the practice of merging all
developers' working copies of code to a shared mainline, several times a day. In other words, CI refers to the coupling of
version control and unit testing in an automated way. Typically, CI runs either when you commit new code to your project, or beforehand,
when you try to merge experimental code into the main repository (through a pull request). CI is useful not only for catching bugs before
they reach your fellow developers and your end users, but also for expanding your testing to platforms that are not available to you.

Most CI services are tightly integrated with Github. In this episode, we will be using [TravisCI](https://travis-ci.org), since it
is free for open-source projects and integrates nicely with Github. Other options you might consider include [CircleCI](https://circleci.com), [Azure Pipelines](https://azure.microsoft.com/en-us/services/devops/pipelines/), and the more recent
[Github Actions](https://github.com/features/actions). 

Using any of these services is essentially getting access to empty remote computers that we can configure as we wish. In order
to test our projects using Travis, we will have to set up the correct environment and tell Travis what to do.

> ## travis-ci.com vs travis-ci.org
>
> If you type TravisCI in your favorite search engine, you will find two official websites, one ending in `.com` and another in `.org`.
> You should click on`travis-ci.com`. The `.org` website used to be specifically for open-source projects, but Travis has since
> merged both services. As a student, you can get the 'Bootstrap' plan for free - see [here](https://education.travis-ci.com/).
{: .callout}

## Setting up TravisCI
All of Travis' settings are stored in the `.travis.yml` file. Note the leading period, which makes this a hidden file in Linux and
Mac OS. Fortunately for us, CookieCutter created this file for us and set it up to run our tests with pytest. If you wanted, you could
go online to `travis-ci.org` right now, link it to your repository, and have Travis automatically execute your tests every time you
pushed to the repository. You wouldn't have to worry about how to configure Travis. However, we will go over this file in detail so
you can understand what is happening under the hood.

So far in this workshop, we have been working in the `molecool/molecool` and `molecool/tests` directories. We will now focus on
the `.travis.yml` file, in the root of your project, and on some other files in the `molecool/devtools` directory.

First, open the `.travis.yml` file. You will see something like the following at the top of the file:

~~~
language: python

# Run jobs on container-based infrastructure, can be overridden per job

matrix:
  include:
    # Extra includes for OSX since python language is not available by default on OSX
    - os: osx
      language: generic
      env: PYTHON_VER=3.6
    - os: osx
      language: generic
      env: PYTHON_VER=3.7


    - os: linux
      language: generic  # No need to set Python version since its conda
      env: PYTHON_VER=3.6
    - os: linux
      language: generic
      env: PYTHON_VER=3.7
~~~
{: .yml}

This first section of the file tells Travis which languages our project is written in, and which operating systems and Python versions
we want to run our integration on. CookieCutter set up su to test our code on four different systems: OSX with Python 3.6, OSX with Python 3.7, Linux with Python 3.6, and Linux with Python 3.7. By default, Travis will run Ubuntu for the Linux, and will automatically
pick the version of both OSX and Ubuntu for you. This is enough for us right now, but if you would want to specify exactly which versions
of the operative systems you wanted to run your tests on, you could!

Before we continue, the configuration file is written in YAML and adheres to a set of specifications. Keywords like `matrix`, `include`,
`before_install`, and `install` are specific to Travis and indicate several steps of the entire CI process. You can always refer to the
[documentation](https://docs.travis-ci.com/) for a list of all the avaialble keywords and a more in-depth explanation of each one.

The second section of the `.travis.yml` file sets up the testing environment. These commands will run on every combination of OS and Python version specified above.

~~~
before_install:
    # Additional info about the build
  - uname -a
  - df -h
  - ulimit -a

    # Install the Python environment
  - source devtools/travis-ci/before_install.sh
  - python -V
~~~
{: .yml}

The part of this script that really does something is the line `source devtools/travis-ci/before_install.sh`. This BASH script installs
Miniconda in the machine where the CI job is running and configures `conda` so that our project's dependencies can be installed. We install Miniconda, instead of using the system's Python installation, to have full control and reproducibility over the CI process. Once this section completes, Travis has an environment running a particular OS and version of Python, with Miniconda installed.

The next section of the configuration file gives instructions for creating a Conda environment and installing our package. As you can see, these are pretty much the same commands we would run on our terminal window.

~~~
install:

    # Create test environment for package
  - python devtools/scripts/create_conda_env.py -n=test -p=$PYTHON_VER devtools/conda-envs/test_env.yaml
    # Activate the test environment
  - conda activate test
    # Build and install package
  - python setup.py develop --no-deps
~~~
{: .yml}

The first line in this section, starting with `-python devtools/scripts`, creates a Conda environment named `test` using the Python script
`create_conda_env.py` and the conda requirements file `test_env.yaml`. This latter file is particularly important for us, since it tells
Travis what packages we need in our testing environment. As such, let's take a closer look.

Open `devtools/conda-envs/test_env.yaml` in your text editor.

~~~
name: test
channels:
dependencies:
    # Base depends
  - python
  - pip

    # Testing
  - pytest
  - pytest-cov
  - codecov

    # Pip-only installs
  #- pip:
  #  - codecov
~~~
{: .yml}

We can see that this file specifies what packages will be installed in this environment. There are the two base dependencies, `python` and `pip`, followed by dependencies specific to unit testing: `pytest`, `pytest-cov`, `codecov`. The last few lines are commented out, but allow you to install certain packages via `pip`, instead of `conda`. Sometimes, some dependencies are not available on any Conda channel but exist on [PyPI](https://pypi.org/).

Since our package depends on `numpy` and `matplotlib`, we need to add these to the `test_env.yaml`.

> ## Exercise
> Add two lines to the `test_env.yaml` specifying `numpy` and `matplotlib` as dependencies that should be installed
> on our CI environment.
>> ## Solution
>> Your `test_env.yaml` should look like this once you are done with your edits:
>>
>> ~~~
>> name: test
>> channels:
>> dependencies:
>>    # Base depends
>>  - python
>>  - pip
>>
>>    # Testing
>>  - pytest
>>  - pytest-cov
>>  - codecov
>>
>>    # Pip-only installs
>>  #- pip:
>>  #  - codecov
>> ~~~
>> {: .yml}
> {: .solution}
{: .challenge}

After these edits, our testing environment is set up and ready to run!

The next line in the YAML file runs our unit tests and produces a coverage report. The command should look very similar to what you executed on your machine in the previous lesson. The only difference is the extra flag to include code coverage.

~~~
script:
  - pytest -v --cov=molecool molecool/tests/
~~~

The last few lines in the `test_env.yaml` file specify that we do not want email notifications (Travis can be set up to send you updates when a build starts, fails, or succeed, via email, or even slack) and that, _if the tests run successfully_, we want to upload our coverage to [Codecov](https://codecov.io/). We will cover this other CI service later in this episode.

> ## Tests, coverage, and much much more!
> We finished setting up our CI workflow with Travis, using the defaults included in the CookieCutter template. This is one way to do it,
> however, note that there are many ways you could have configured this workflow with the exact same effects. Similarly, you can use 
> Travis to run more than just pytest. Several open-source projects use Travis and other CI services to automate multiple steps of their 
> development pipeline, namely style checking, unit testing, building documentation, and even building and uploading packages to conda 
> and PyPI.
{: .callout}

## Setting up travis-ci.com
- Next, you should navigate to travis-ci.org and hook it to this repository. Demonstrate a push and watch the tests run automatically

## Describe code coverage
    - Explain why it is important
    - Explain what it is *not*
    - Explain how to enable it

{% include links.md %}
